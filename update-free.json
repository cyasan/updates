{
  "version": "9.1.9",
  "update": [
    {
      "path": "plugins/special/runtime.js",
      "code": "exports.run = {\nusage: ['runtime'],\nhidden: ['test'],\ncategory: 'special',\nasync: async (m, { func, mecha, setting, fkon }) => {\nmecha.sendMessageModify(m.chat, `Quick Test Done! ${m.pushname}`, fkon, {\ntitle: 'Aktif Selama :',\nbody: func.runtime(process.uptime()),\nthumbUrl: setting.cover,\nlargeThumb: false,\nurl: null,\nexpiration: m.expiration\n})\n}\n}"
    },
    {
      "path": "plugins/downloader/play.js",
      "code": "const axios = require('axios');\n\nasync function downloadImage(url) {\ntry {\nconst response = await axios.get(url, { responseType: 'arraybuffer' });\nreturn Buffer.from(response.data, 'binary');\n} catch (error) {\nreturn null;\n}\n}\n\nexports.run = {\nusage: ['play'],\nuse: 'judul lagu',\ncategory: 'downloader',\nasync: async (m, { func, lulli }) => {\nlulli.play = lulli.play ? lulli.play : {};\nif (!m.text) return m.reply(func.example(m.cmd, 'melukis senja'));\nlulli.sendReact(m.chat, 'ðŸ•’', m.key);\ntry {\nlet searchResults = await YT.search(m.text)\nlet data = searchResults[0];\nif (!data) {\nlulli.sendReact(m.chat, 'âŒ', m.key);\nreturn m.reply('Video/Audio tidak ditemukan.');\n}\nlet durationInSeconds = data.duration.split(':').reduce((acc, time) => (60 * acc) + +time);\nif (durationInSeconds >= 3600) {\nlulli.sendReact(m.chat, 'âŒ', m.key);\nreturn m.reply('Video is longer than 1 hour!');\n} else {\nlet caption = `âˆ˜ ID : ${data.id}`;\ncaption += `\\nâˆ˜ Title : ${data.title}`;\ncaption += `\\nâˆ˜ Duration : ${data.duration}`;\ncaption += `\\nâˆ˜ Views : ${data.viewCount}`;\ncaption += `\\nâˆ˜ Upload : ${data.publishedAt}`;\ncaption += `\\nâˆ˜ Author : ${data.channelTitle}`;\ncaption += `\\nâˆ˜ Video URL : ${data.url}`;\ncaption += `\\n\\n_reply with number *1* to get audio_`;\ncaption += `\\n_reply with number *2* to get video_`;\ncaption += `\\n_reply with number *3* to get document_`;\nconst thumbnailBuffer = await downloadImage(data.thumbMedium);\nconst result = await YouTubeDownloader.download(data.url, {\nmp4: '360',\nmp3: '128'\n})\nlulli.play[m.sender] = {\ndata: {\nurl: data.url,\nthumbnail: thumbnailBuffer,\nduration: data.duration,\ntitle: data.title,\naudio: result.mp3,\nvideo: result.mp4\n},\naudio: true,\nvideo: true,\ndocument: true,\ntimeout: setTimeout(function () {\ndelete lulli.play[m.sender];\n}, 1000 * 60 * 10)\n};\nlet messageId = 'LULLI' + func.makeid(22).toUpperCase() + 'PLAY';\nawait lulli.relayMessage(m.chat, {\nextendedTextMessage: {\ntext: caption,\ncontextInfo: {\nexternalAdReply: {\ntitle: data.title,\nmediaType: 1,\npreviewType: 0,\nrenderLargerThumbnail: true,\nthumbnail: thumbnailBuffer,\nsourceUrl: data.url\n}\n},\nmentions: [m.sender]\n}\n}, { quoted: m, ephemeralExpiration: m.expiration, messageId: messageId });\nlulli.sendReact(m.chat, 'âœ…', m.key);\n}\n} catch (error) {\nlulli.sendReact(m.chat, 'âŒ', m.key);\n}\n},\nmain: async (m, { func, lulli }) => {\nlulli.play = lulli.play ? lulli.play : {};\nif (lulli.play[m.sender] && m.budy && m.quoted && m.quoted.fromMe && m.quoted.id.endsWith('PLAY') && !m.isPrefix) {\nif (!isNaN(m.budy) && func.somematch(['1', '2', '3'], m.budy)) {\nlulli.sendReact(m.chat, 'ðŸ•’', m.key);\nlet result = lulli.play[m.sender];\nlet typefile = /1/.test(m.budy) ? 'audio' : /2/.test(m.budy) ? 'video' : 'document';\nlet ext = /1/.test(m.budy) ? '.mp3' : /2/.test(m.budy) ? '.mp4' : '.mp3';\nlet mimetype = /1/.test(m.budy) ? 'audio/mpeg' : /2/.test(m.budy) ? 'video/mp4' : 'audio/mpeg';\ntry {\nawait lulli.sendMessage(m.chat, {\n[typefile]: {\nurl: result.data[typefile === 'audio' ? 'audio' : 'video']\n},\ncaption: result.data.title,\nmimetype: mimetype,\nfileName: result.data.title + ext,\ncontextInfo: {\nexternalAdReply: {\ntitle: result.data.title,\nbody: `${result.data.duration}`,\nthumbnail: result.data.thumbnail,\nmediaType: 2,\nmediaUrl: result.data.url,\nsourceUrl: result.data.url\n}\n}\n}, { quoted: m, ephemeralExpiration: m.expiration }).then(_ => {\nresult[typefile] = false;\nif (!result.audio && !result.video && !result.document) delete lulli.play[m.sender];\n});\nlulli.sendReact(m.chat, 'âœ…', m.key);\n} catch (error) {\nlulli.sendReact(m.chat, 'âŒ', m.key);\nlulli.reply(m.chat, String(error), m, {\nexpiration: m.expiration\n})\n}\n}\n}\n},\nrestrict: true,\nlimit: 3\n}"
    },
    {
      "path": "plugins/ai/ai.js",
      "code": "/*\nScrape: Avosky\n*/\nconst axios = require('axios');\nconst cleanResponse = (text) => {\nreturn text\n.replace(/\\*\\*(.*?)\\*\\*/g, '$1')\n.replace(/__(.*?)__/g, '$1')\n.replace(/\\*(.*?)\\*/g, '$1')\n.replace(/_(.*?)_/g, '$1')\n.replace(/`(.*?)`/g, '$1')\n.replace(/\\[(.*?)\\]\\(.*?\\)/g, '$1')\n.replace(/~~(.*?)~~/g, '$1')\n.replace(/#+\\s*(.*)/g, '$1')\n.replace(/!\\[.*?\\]\\(.*?\\)/g, '')\n.replace(/<[^>]+>/g, '')\n.replace(/[ \\t]+/g, ' ')\n.replace(/\\$@\\$(.*?)\\$@\\$/g, '')\n.trim();\n};\nconst headers = {\n\"Content-Type\": \"application/json\",\n\"User-Agent\": \"Mozilla/5.0 (Linux; Android 12; Infinix HOT 40 Pro Build/SKQ1.210929.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/96.0.4664.45 Mobile Safari/537.36\",\n\"Accept\": \"application/json\", \n\"Accept-Language\": \"en-US,en;q=0.9,id;q=0.8\",\n\"Connection\": \"keep-alive\",\n\"Host\": \"bagoodex.io\",\n\"X-Requested-With\": \"XMLHttpRequest\",\n\"DNT\": \"1\",\n\"Sec-Ch-Ua\": '\"Google Chrome\";v=\"96\", \"Not A(Brand\";v=\"99\", \"Chromium\";v=\"96\"',\n\"Sec-Ch-Ua-Mobile\": '?1',\n\"Sec-Ch-Ua-Platform\": '\"Android\"',\n\"Referer\": \"https://bagoodex.io/\",\n\"Origin\": \"https://bagoodex.io\",\n\"Accept-Encoding\": \"gzip, deflate, br\",\n\"Cache-Control\": \"no-cache\"\n};\n\nexports.run = {\nusage: ['ai'],\nuse: 'question', \ncategory: 'ai',\nasync: async (m, { func, mecha, users }) => {\nconst processRequest = async (input, name) => {\nconst payload = {\nprompt: `kamu adalah Mecha, Bot WhatsApp dengan program kecerdasan buatan AI (artificial intelligence). jawab setiap pertanyaan dengan jawaban yang edukatif, lawan bicaramu adalah ${name}, kamu memiliki sifat dingin dan sedikit tsundere imut, kamu dirancang dan dikembangkan oleh SuryaDev sejak tahun 2021, SuryaDev memiliki nama lengkap Jabal Surya Ngalam, berasal dari Jepara, lahir pada 21 mei 2005, dia adalah seseorang yang kreatif dan berbakat dalam menciptakan berbagai hal.`,\nmessages: [{\ncontent: \"hai! aku siap membantu! apa yang bisa aku bantu? (*ï¼¾â–½ï¼¾)ï¼\",\nrole: \"system\"\n}],\ninput: input\n};\nconst response = await axios.post('https://bagoodex.io/front-api/chat', payload, { headers });\nconst cleanedResponse = cleanResponse(response.data);\nreturn cleanedResponse;\n};\nif (!m.text) return m.reply(func.example(m.cmd, 'apa itu coding?'));\nmecha.sendReact(m.chat, 'ðŸ•’', m.key);\nconst replyText = await processRequest(m.text, users.name);\nmecha.sendReact(m.chat, 'âœ…', m.key);\nmecha.reply(m.chat, replyText, m, {\nexpiration: m.expiration\n});\n},\nlimit: true\n}"
    },
    {
      "path": "plugins/searching/gmailstalk.js",
      "code": "/*\n*[ GMAIL PROFILE CHECKER ]*\n\nðŸ§‘â€ðŸ’» Script Code by Daffa\n*/\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst checkGmail = async (email) => {\nreturn new Promise(async (resolve, reject) => {\ntry {\nconst username = email.split('@')[0];\nconst { data } = await axios.post(\n'https://gmail-osint.activetk.jp/',\nnew URLSearchParams({\nq: username,\ndomain: 'gmail.com'\n}),\n{\nheaders: {\n'Content-Type': 'application/x-www-form-urlencoded',\n'User-Agent': 'Postify/1.0.0'\n}\n}\n);\nconst $ = cheerio.load(data);\nconst text = $('pre').text();\nconst extract = (regex, defaultValue = 'Tidak ada', checkNotFound = false) => {\nconst result = (text.match(regex) || [null, defaultValue])[1].trim();\nreturn checkNotFound && result === 'Not found.' ? 'Tidak ada' : result;\n};\nresolve({\nstatus: 200,\nresult: {\nemail: email,\nphotoProfile: extract(/Custom profile picture !\\s*=>\\s*(.*)/, 'Tidak ada'),\nlastEditProfile: extract(/Last profile edit : (.*)/),\ngoogleID: extract(/Gaia ID : (.*)/),\nuserTypes: extract(/User types : (.*)/),\ngoogleChat: {\nentityType: extract(/Entity Type : (.*)/),\ncustomerID: extract(/Customer ID : (.*)/, 'Tidak ada', true)\n},\ngooglePlus: {\nenterpriseUser: extract(/Entreprise User : (.*)/)\n},\nmapsData: {\nprofilePage: extract(/Profile page : (.*)/)\n},\nipAddress: text.includes('Your IP has been blocked by Google') ? 'Di blokir oleh Google' : 'Aman',\ncalendar: text.includes('No public Google Calendar') ? 'Tidak ada' : 'Ada'\n}\n});\n} catch (error) {\nresolve({\nstatus: 404,\nmsg: 'Email tidak ditemukan atau terjadi kesalahan!'\n});\n}\n});\n};\nexports.run = {\nusage: ['gmailstalk'],\nhidden: [],\nuse: 'email@gmail.com',\ncategory: 'searching',\nasync: async (m, { func, mecha }) => {\nif (!m.args[0]) return m.reply(func.example(m.cmd, 'example@gmail.com'))\nif (!m.args[0].endsWith('@gmail.com')) return m.reply('Masukkan email Gmail yang valid!')\nawait checkGmail(m.args[0]).then(data => {\nif (data.status == 404) return m.reply(data.msg)\nlet txt = `ä¹‚  *GMAIL CHECKER*\\n`\ntxt += `\\nâ—¦  *Email:* ${data.result.email}`\ntxt += `\\nâ—¦  *Photo Profile:* ${data.result.photoProfile}`\ntxt += `\\nâ—¦  *Last Edit:* ${data.result.lastEditProfile}`\ntxt += `\\nâ—¦  *Google ID:* ${data.result.googleID}`\ntxt += `\\nâ—¦  *User Types:* ${data.result.userTypes}`\ntxt += `\\nâ—¦  *Entity Type:* ${data.result.googleChat.entityType}`\ntxt += `\\nâ—¦  *Customer ID:* ${data.result.googleChat.customerID}`\ntxt += `\\nâ—¦  *Enterprise User:* ${data.result.googlePlus.enterpriseUser}`\ntxt += `\\nâ—¦  *Profile Page:* ${data.result.mapsData.profilePage}`\ntxt += `\\nâ—¦  *IP Status:* ${data.result.ipAddress}`\ntxt += `\\nâ—¦  *Calendar:* ${data.result.calendar}`\nmecha.reply(m.chat, txt, m)\n})\n},\nlimit: true\n}"
    }
  ],
  "remove": [
    "plugins/y.js"
  ]
}