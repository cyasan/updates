{
  "version": "9.1.9",
  "update": [
    {
      "path": "plugins/special/runtime.js",
      "code": "exports.run = {\nusage: ['runtime'],\nhidden: ['test'],\ncategory: 'special',\nasync: async (m, { func, mecha, setting, fkon }) => {\nmecha.sendMessageModify(m.chat, `Quick Test Done! ${m.pushname}`, fkon, {\ntitle: 'Aktif Selama :',\nbody: func.runtime(process.uptime()),\nthumbUrl: setting.cover,\nlargeThumb: false,\nurl: null,\nexpiration: m.expiration\n})\n}\n}"
    },
    {
      "path": "plugins/downloader/play.js",
      "code": "const axios = require('axios');\n\nasync function downloadImage(url) {\ntry {\nconst response = await axios.get(url, { responseType: 'arraybuffer' });\nreturn Buffer.from(response.data, 'binary');\n} catch (error) {\nreturn null;\n}\n}\n\nexports.run = {\nusage: ['play'],\nuse: 'judul lagu',\ncategory: 'downloader',\nasync: async (m, { func, lulli }) => {\nlulli.play = lulli.play ? lulli.play : {};\nif (!m.text) return m.reply(func.example(m.cmd, 'melukis senja'));\nlulli.sendReact(m.chat, 'üïí', m.key);\ntry {\nlet searchResults = await YT.search(m.text)\nlet data = searchResults[0];\nif (!data) {\nlulli.sendReact(m.chat, '‚ùå', m.key);\nreturn m.reply('Video/Audio tidak ditemukan.');\n}\nlet durationInSeconds = data.duration.split(':').reduce((acc, time) => (60 * acc) + +time);\nif (durationInSeconds >= 3600) {\nlulli.sendReact(m.chat, '‚ùå', m.key);\nreturn m.reply('Video is longer than 1 hour!');\n} else {\nlet caption = `‚àò ID : ${data.id}`;\ncaption += `\\n‚àò Title : ${data.title}`;\ncaption += `\\n‚àò Duration : ${data.duration}`;\ncaption += `\\n‚àò Views : ${data.viewCount}`;\ncaption += `\\n‚àò Upload : ${data.publishedAt}`;\ncaption += `\\n‚àò Author : ${data.channelTitle}`;\ncaption += `\\n‚àò Video URL : ${data.url}`;\ncaption += `\\n\\n_reply with number *1* to get audio_`;\ncaption += `\\n_reply with number *2* to get video_`;\ncaption += `\\n_reply with number *3* to get document_`;\nconst thumbnailBuffer = await downloadImage(data.thumbMedium);\nconst result = await YouTubeDownloader.download(data.url, {\nmp4: '360',\nmp3: '128'\n})\nlulli.play[m.sender] = {\ndata: {\nurl: data.url,\nthumbnail: thumbnailBuffer,\nduration: data.duration,\ntitle: data.title,\naudio: result.mp3,\nvideo: result.mp4\n},\naudio: true,\nvideo: true,\ndocument: true,\ntimeout: setTimeout(function () {\ndelete lulli.play[m.sender];\n}, 1000 * 60 * 10)\n};\nlet messageId = 'LULLI' + func.makeid(22).toUpperCase() + 'PLAY';\nawait lulli.relayMessage(m.chat, {\nextendedTextMessage: {\ntext: caption,\ncontextInfo: {\nexternalAdReply: {\ntitle: data.title,\nmediaType: 1,\npreviewType: 0,\nrenderLargerThumbnail: true,\nthumbnail: thumbnailBuffer,\nsourceUrl: data.url\n}\n},\nmentions: [m.sender]\n}\n}, { quoted: m, ephemeralExpiration: m.expiration, messageId: messageId });\nlulli.sendReact(m.chat, '‚úÖ', m.key);\n}\n} catch (error) {\nlulli.sendReact(m.chat, '‚ùå', m.key);\n}\n},\nmain: async (m, { func, lulli }) => {\nlulli.play = lulli.play ? lulli.play : {};\nif (lulli.play[m.sender] && m.budy && m.quoted && m.quoted.fromMe && m.quoted.id.endsWith('PLAY') && !m.isPrefix) {\nif (!isNaN(m.budy) && func.somematch(['1', '2', '3'], m.budy)) {\nlulli.sendReact(m.chat, 'üïí', m.key);\nlet result = lulli.play[m.sender];\nlet typefile = /1/.test(m.budy) ? 'audio' : /2/.test(m.budy) ? 'video' : 'document';\nlet ext = /1/.test(m.budy) ? '.mp3' : /2/.test(m.budy) ? '.mp4' : '.mp3';\nlet mimetype = /1/.test(m.budy) ? 'audio/mpeg' : /2/.test(m.budy) ? 'video/mp4' : 'audio/mpeg';\ntry {\nawait lulli.sendMessage(m.chat, {\n[typefile]: {\nurl: result.data[typefile === 'audio' ? 'audio' : 'video']\n},\ncaption: result.data.title,\nmimetype: mimetype,\nfileName: result.data.title + ext,\ncontextInfo: {\nexternalAdReply: {\ntitle: result.data.title,\nbody: `${result.data.duration}`,\nthumbnail: result.data.thumbnail,\nmediaType: 2,\nmediaUrl: result.data.url,\nsourceUrl: result.data.url\n}\n}\n}, { quoted: m, ephemeralExpiration: m.expiration }).then(_ => {\nresult[typefile] = false;\nif (!result.audio && !result.video && !result.document) delete lulli.play[m.sender];\n});\nlulli.sendReact(m.chat, '‚úÖ', m.key);\n} catch (error) {\nlulli.sendReact(m.chat, '‚ùå', m.key);\nlulli.reply(m.chat, String(error), m, {\nexpiration: m.expiration\n})\n}\n}\n}\n},\nrestrict: true,\nlimit: 3\n}"
    },
    {
      "path": "plugins/ai/lbbai.js",
      "code": "const axios = require('axios');\nconst fs = require('fs');\nconst qs = require('qs');\nconst crypto = require('crypto');\nconst { G4F } = require(\"g4f\");\nconst g4f = new G4F();\n\nexports.run = {\nusage: ['lbbai'],\nhidden: ['gpt'],\nuse: 'text',\ncategory: 'ai',\nasync: async (m, { func, mecha, users, errorMessage }) => {\nconst whisper = require(fs.existsSync('../lib/whisper.js') ? './lib/whisper.js' : '../../lib/whisper.js');\nif (!m.text) return m.reply(func.example(m.cmd, 'Hai'))\nmecha.sendReact(m.chat, 'üïí', m.key)\ntry {\nlet messageId = 'MECHA' + func.makeid(8).toUpperCase() + 'GPT'\nlet response = await Lbbai(m.text, users.name.replaceAll('\\n', '\\t'))\nmecha.sendMessage(m.chat, {text: `${response}`}, {quoted: m, ephemeralExpiration: m.expiration, messageId: messageId});\n} catch (error) {\nmecha.sendReact(m.chat, '‚ùå', m.key)\nreturn errorMessage(error)\n}\n},\nmain: async (m, { func, mecha, users, quoted, errorMessage }) => {\nconst sendVoiceMessage = async (jid, text) => {\nawait tiktokTts(text, 'id_001').then(async result => {\nif (!result.success) return await mecha.sendMessage(jid, {text: text}, {quoted: m, ephemeralExpiration: m.expiration});\nreturn await mecha.sendMessage(jid, {audio: result.base64, mimetype: 'audio/mp4', ptt: true}, {quoted: m, ephemeralExpiration: m.expiration})\n})\n}\n\nif (m.budy && m.arg && /mecha/i.test(m.arg[0])) {\nif (!m.text) return m.reply('Halo! Ada yang bisa aku bantu hari ini?')\nmecha.sendReact(m.chat, 'üïí', m.key)\ntry {\nlet messageId = 'MECHA' + func.makeid(8).toUpperCase() + 'GPT'\nlet response = await Lbbai(m.text, users.name.replaceAll('\\n', '\\t'))\nmecha.sendMessage(m.chat, {text: `${response}`}, {quoted: m, ephemeralExpiration: m.expiration, messageId: messageId});\n} catch (error) {\nmecha.sendReact(m.chat, '‚ùå', m.key)\nreturn errorMessage(error)\n}\n} else if (m.budy && m.quoted && m.quoted.fromMe && m.quoted.id.endsWith('GPT') && !m.isPrefix) {\nmecha.sendReact(m.chat, 'üïí', m.key)\ntry {\nlet messageId = 'MECHA' + func.makeid(8).toUpperCase() + 'GPT'\n//let messageId = 'BAE5' + func.makeid(9).toUpperCase() + 'GPT'\nlet response = await Lbbai(m.budy, users.name.replaceAll('\\n', '\\t'))\nawait tiktokTts(response, 'id_001').then(async result => {\nif (!result.success) return mecha.sendMessage(m.chat, {text: `${response}`}, {quoted: m, ephemeralExpiration: m.expiration, messageId: messageId});\nawait mecha.sendMessage(m.chat, {audio: result.base64, mimetype: 'audio/mp4', ptt: true}, {quoted: m, ephemeralExpiration: m.expiration, messageId: messageId})\n})\nusers.limit -= 3\n} catch (error) {\nmecha.sendReact(m.chat, '‚ùå', m.key)\nreturn errorMessage(error)\n}\n}\nif (/audio/.test(m.mime) && m.seconds < 10 && !m.fromMe) {\nmecha.sendReact(m.chat, 'üïí', m.key)\ntry {\nlet messageId = 'MECHA' + func.makeid(8).toUpperCase() + 'GPT'\nlet media = await m.download();\ntry {\nvar result = (await whisper(media)).transcribe || '';\n} catch {\nvar result = '';\n}\nif (result === '') return mecha.sendReact(m.chat, '', m.key)\nif (!/mecha|luli|luly/i.test(result)) return mecha.sendReact(m.chat, '', m.key)\nconst text = result; //.replace(/mecha/g, '')\nif (m.isGc && m.isOwner && /tutup (grup|group)/i.test(text)) {\nif (!m.isBotAdmin) return sendVoiceMessage(m.chat, 'maaf tuan, saya bukan admin di grup ini.')\nawait mecha.groupSettingUpdate(m.chat, 'announcement')\n.then((res) => sendVoiceMessage(m.chat, 'baik tuan, grup ini sudah saya tutup.'))\n.catch((err) => sendVoiceMessage(m.chat, 'maaf tuan, terjadi kesalahan.'))\nreturn !0;\n} else if (m.isGc && m.isOwner && /buka (grup|group)/i.test(text)) {\nif (!m.isBotAdmin) return sendVoiceMessage(m.chat, 'maaf tuan, saya bukan admin di grup ini.')\nawait mecha.groupSettingUpdate(m.chat, 'not_announcement')\n.then((res) => sendVoiceMessage(m.chat, 'baik tuan, grup ini sudah saya buka.'))\n.catch((err) => sendVoiceMessage(m.chat, 'maaf tuan, terjadi kesalahan.'))\nreturn !0;\n}\nlet response = await Lbbai(text, users.name.replaceAll('\\n', '\\t'))\nmecha.sendMessage(m.chat, {text: `${response}`}, {quoted: m, ephemeralExpiration: m.expiration, messageId: messageId});\n} catch (error) {\nconsole.error(\"Error in main function:\", error);\nreturn mecha.reply(m.chat, String(error), m)\n}\n}\n},\nlimit: true\n}\n\nfunction detectLanguage(text) {\n// Daftar kata dasar sederhana untuk bahasa Inggris dan Indonesia\nconst englishWords = ['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'I'];\nconst indonesianWords = ['dan', 'di', 'yang', 'ke', 'dari', 'ini', 'itu', 'dengan', 'untuk', 'sebagai'];\n\nlet englishCount = 0;\nlet indonesianCount = 0;\n\nconst words = text.toLowerCase().split(/\\s+/);\n\nwords.forEach(word => {\nif (englishWords.includes(word)) {\nenglishCount++;\n}\nif (indonesianWords.includes(word)) {\nindonesianCount++;\n}\n});\n\nreturn englishCount > indonesianCount ? 'en_us_001' : 'id_001';\n}\n\nfunction bersihkanInput(input) {\n// Ekspresi reguler untuk mencocokkan karakter yang diizinkan\nconst regex = /[^a-zA-Z0-9.,! ]/g;\n// Mengganti semua karakter yang tidak diizinkan dengan string kosong\nconst bersih = input.replace(regex, '');\nreturn bersih;\n}\n\n\nasync function tiktokTts(text) {\ntry {\nconst modelVoice = detectLanguage(text);\nconst input = bersihkanInput(text);\nconst { status, data } = await axios('https://tiktok-tts.weilnet.workers.dev/api/generation', {\nmethod: \"POST\",\ndata: {\ntext: input,\nvoice: modelVoice\n},\nheaders: {\n\"content-type\": \"application/json\",\n},\n}\n);\nreturn {\nsuccess: true,\ncreator: 'SuryaDev',\nbase64: Buffer.from(data.data, \"base64\")\n}\n} catch (err) {\nconsole.log(err.response.data);\nreturn err.response.data;\n}\n}\n\nfunction generateUUIDv4() {\nreturn ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => (c ^ crypto.randomBytes(1)[0] & 15 >> c / 4).toString(16));\n}\n\nasync function chatWithAI(text) {\ntry {\nconst conversation_uuid = generateUUIDv4();\nconst requestData = {\nconversation_uuid: conversation_uuid,\ntext: text,\nsent_messages: 1\n};\n\nconst config = {\nheaders: {\n'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n'Accept': '*/*',\n'X-Requested-With': 'XMLHttpRequest'\n}\n};\n\nconst response = await axios.post('https://www.timospecht.de/wp-json/cgt/v1/chat', qs.stringify(requestData), config);\nif (!response.data.success) return 'Terjadi kesalahan.'\nreturn response.data.data.message;\n} catch (error) {\nthrow new Error('Terjadi kesalahan:', error);\n}\n}\n\nasync function Lbbai(input, name) {\ntry {\nconst today = new Date();\nconst date = new Date(today.toLocaleString(\"en-US\", {timeZone: \"Asia/Jakarta\"}));\nconst hours = date.getHours();\nconst minutes = date.getMinutes();\nconst day = today.getDate();\nconst month = today.getMonth() + 1; // perhatikan bahwa bulan dimulai dari 0, maka ditambahkan 1.\nconst year = today.getFullYear();\n// mengambil nama hari dalam bahasa Inggris.\nconst dayOfWeek = today.toLocaleDateString(\"id-ID\", { weekday: \"long\" });\nconst timeNow = `${hours.toString().padStart(2, \"0\")}:${minutes.toString().padStart(2, \"0\")}`;\nconst getTodayDate = `Hari ini adalah ${dayOfWeek}, ${day}/${month}/${year}.`;\nconst sistem = `kamu adalah mecha, Bot WhatsApp dengan program kecerdasan buatan AI (artificial intelligence). jawab setiap pertanyaan dengan jawaban yang edukatif, jika ada yang bertanya tentang waktu kamu jawab yang berkaitan dengan ${timeNow} dan ${getTodayDate}, lawan bicaramu adalah ${name}, kamu memiliki sifat dingin dan sedikit tsundere imut, kamu dirancang dan dikembangkan oleh SuryaDev sejak tahun 2021, SuryaDev memiliki nama lengkap Jabal Surya Ngalam, berasal dari Jepara, lahir pada 21 mei 2005, dia adalah seseorang yang kreatif dan berbakat dalam menciptakan berbagai hal.`\nconst response = await axios.post('https://ragbot-starter.vercel.app/api/chat', {\nmessages: [\n{\nrole: \"system\",\ncontent: sistem\n},\n{\nrole: \"user\",\ncontent: input\n}\n],\nuseRag: true,\nllm: 'gpt-3.5-turbo',\nsimilarityMetric: 'cosine'\n});\nif (response.data.includes(\"I'm sorry, I don't know the answer.\")) {\nconst { data } = await axios.get(`https://api.vreden.my.id/api/qioo?query=${encodeURIComponent(input)}&username=${name}`)\nreturn (data.result || '').replace('Generated by BLACKBOX.AI, try unlimited chat https://www.blackbox.ai\\n\\n', '')\n} else {\nreturn response.data;\n}\n} catch (error) {\nthrow error;\n}\n}"
    },
    {
      "path": "plugins/ai/ai.js",
      "code": "/*\nScrape: Avosky\n*/\nconst axios = require('axios');\nconst cleanResponse = (text) => {\nreturn text\n.replace(/\\*\\*(.*?)\\*\\*/g, '$1')\n.replace(/__(.*?)__/g, '$1')\n.replace(/\\*(.*?)\\*/g, '$1')\n.replace(/_(.*?)_/g, '$1')\n.replace(/`(.*?)`/g, '$1')\n.replace(/\\[(.*?)\\]\\(.*?\\)/g, '$1')\n.replace(/~~(.*?)~~/g, '$1')\n.replace(/#+\\s*(.*)/g, '$1')\n.replace(/!\\[.*?\\]\\(.*?\\)/g, '')\n.replace(/<[^>]+>/g, '')\n.replace(/[ \\t]+/g, ' ')\n.replace(/\\$@\\$(.*?)\\$@\\$/g, '')\n.trim();\n};\nconst headers = {\n\"Content-Type\": \"application/json\",\n\"User-Agent\": \"Mozilla/5.0 (Linux; Android 12; Infinix HOT 40 Pro Build/SKQ1.210929.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/96.0.4664.45 Mobile Safari/537.36\",\n\"Accept\": \"application/json\", \n\"Accept-Language\": \"en-US,en;q=0.9,id;q=0.8\",\n\"Connection\": \"keep-alive\",\n\"Host\": \"bagoodex.io\",\n\"X-Requested-With\": \"XMLHttpRequest\",\n\"DNT\": \"1\",\n\"Sec-Ch-Ua\": '\"Google Chrome\";v=\"96\", \"Not A(Brand\";v=\"99\", \"Chromium\";v=\"96\"',\n\"Sec-Ch-Ua-Mobile\": '?1',\n\"Sec-Ch-Ua-Platform\": '\"Android\"',\n\"Referer\": \"https://bagoodex.io/\",\n\"Origin\": \"https://bagoodex.io\",\n\"Accept-Encoding\": \"gzip, deflate, br\",\n\"Cache-Control\": \"no-cache\"\n};\n\nexports.run = {\nusage: ['ai'],\nuse: 'question', \ncategory: 'ai',\nasync: async (m, { func, mecha, users }) => {\nconst processRequest = async (input, name) => {\nconst payload = {\nprompt: `kamu adalah Mecha, Bot WhatsApp dengan program kecerdasan buatan AI (artificial intelligence). jawab setiap pertanyaan dengan jawaban yang edukatif, lawan bicaramu adalah ${name}, kamu memiliki sifat dingin dan sedikit tsundere imut, kamu dirancang dan dikembangkan oleh SuryaDev sejak tahun 2021, SuryaDev memiliki nama lengkap Jabal Surya Ngalam, berasal dari Jepara, lahir pada 21 mei 2005, dia adalah seseorang yang kreatif dan berbakat dalam menciptakan berbagai hal.`,\nmessages: [{\ncontent: \"hai! aku siap membantu! apa yang bisa aku bantu? (*Ôºæ‚ñΩÔºæ)Ôºè\",\nrole: \"system\"\n}],\ninput: input\n};\nconst response = await axios.post('https://bagoodex.io/front-api/chat', payload, { headers });\nconst cleanedResponse = cleanResponse(response.data);\nreturn cleanedResponse;\n};\nif (!m.text) return m.reply(func.example(m.cmd, 'apa itu coding?'));\nmecha.sendReact(m.chat, 'üïí', m.key);\nconst replyText = await processRequest(m.text, users.name);\nmecha.sendReact(m.chat, '‚úÖ', m.key);\nmecha.reply(m.chat, replyText, m, {\nexpiration: m.expiration\n});\n},\nlimit: true\n}"
    },
    {
      "path": "plugins/convert/quickchat.js",
      "code": "const axios = require('axios')\n\nexports.run = {\nusage: ['quickchat'],\nhidden: ['qc'],\nuse: 'text',\ncategory: 'convert',\nasync: async (m, { func, lulli, packname, author }) => {\nconst backgroundColor = {\n'pink': '#f68ac9',\n'biru': '#6cace4',\n'merah': '#f44336',\n'hijau': '#4caf50',\n'kuning': '#ffeb3b',\n'ungu': '#9c27b0',\n'birutua': '#0d47a1',\n'birumuda': '#03a9f4',\n'abu': '#9e9e9e',\n'orange': '#ff9800',\n'hitam': '#000000',\n'putih': '#ffffff',\n'teal': '#008080',\n'merahmuda': '#FFC0CB',\n'cokelat': '#A52A2A',\n'salmon': '#FFA07A',\n'magenta': '#FF00FF',\n'tan': '#D2B48C',\n'wheat': '#F5DEB3',\n'deeppink': '#FF1493',\n'api': '#B22222',\n'birulangit': '#00BFFF',\n'jingga': '#FF7F50',\n'birulangitcerah': '#1E90FF',\n'hotpink': '#FF69B4',\n'birumudalangit': '#87CEEB',\n'hijaulaut': '#20B2AA',\n'merahtua': '#8B0000',\n'oranyemerah': '#FF4500',\n'cyan': '#48D1CC',\n'ungutua': '#BA55D3',\n'hijaulumut': '#00FF7F',\n'hijaugelap': '#008000',\n'birulaut': '#191970',\n'oranyetua': '#FF8C00',\n'ungukehitaman': '#9400D3',\n'fuchsia': '#FF00FF',\n'magentagelap': '#8B008B',\n'abu-abutua': '#2F4F4F',\n'peachpuff': '#FFDAB9',\n'hijautua': '#BDB76B',\n'merahgelap': '#DC143C',\n'goldenrod': '#DAA520',\n'abu-abumuda': '#696969',\n'ungugelap': '#483D8B',\n'emas': '#FFD700',\n'perak': '#C0C0C0',\n}\nif (!m.text) return m.reply(func.example(m.cmd, '1 suryadev'))\nif (m.text.length > 100) return m.reply('Max 100 character.')\nconst listColor = Object.keys(backgroundColor).map((color, index) => `${index + 1}. ${color}`).join('\\n')\nlet [indexColor, ...message] = m.text.split(' ');\nif (!(indexColor && message.length > 0)) return m.reply(`Invalid format!\\n\\nContoh: ${m.cmd} 1 suryadev\\n\\n*List Color* :\\n${listColor}`)\nindexColor = parseInt(indexColor);\nmessage = message.join(' ');\nlet colorData = Object.values(backgroundColor)\nif (indexColor < 1 || indexColor > colorData.length) return m.reply(`Warna yang dipilih tidak tersedia.\\n\\n*List Color* :\\n${listColor}`)\nlulli.sendReact(m.chat, 'üïí', m.key)\nlet kodeColor = colorData[indexColor - 1];\ntry {\nconst obj = {\ntype: \"quote\",\nformat: \"png\",\nbackgroundColor: kodeColor,\nwidth: 512,\nheight: 768,\nscale: 2,\nmessages: [{\nentities: [],\navatar: true,\nfrom: {\nid: 5,\nname: m.quoted ? global.db.users[m.quoted.sender].name : m.pushname,\nphoto: {\nurl: await lulli.profilePictureUrl(m.quoted ? m.quoted.sender : m.sender, 'image').catch(_ => 'https://telegra.ph/file/320b066dc81928b782c7b.png')\n}\n},\ntext: message,\nreplyMessage: {}\n}]\n}\nlet res = await axios.post(global.quoteApi, obj, {\nheaders: {\n'Content-Type': 'application/json'\n}\n})\nconst buffer = Buffer.from(res.data.result.image, 'base64')\nlulli.sendSticker(m.chat, buffer, m, {\npackname: packname, \nauthor: author,\nexpiration: m.expiration\n})\n} catch (e) {\nreturn lulli.reply(m.chat, `Error om server qc nya: ${String(e)}`, m, {\nexpiration: m.expiration\n})\n}\n},\n//premium: true,\nrestrict: true,\nlimit: 3\n}"
    },
    {
      "path": "plugins/searching/gmailstalk.js",
      "code": "/*\n*[ GMAIL PROFILE CHECKER ]*\n\nüßë‚Äçüíª Script Code by Daffa\n*/\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst checkGmail = async (email) => {\nreturn new Promise(async (resolve, reject) => {\ntry {\nconst username = email.split('@')[0];\nconst { data } = await axios.post(\n'https://gmail-osint.activetk.jp/',\nnew URLSearchParams({\nq: username,\ndomain: 'gmail.com'\n}),\n{\nheaders: {\n'Content-Type': 'application/x-www-form-urlencoded',\n'User-Agent': 'Postify/1.0.0'\n}\n}\n);\nconst $ = cheerio.load(data);\nconst text = $('pre').text();\nconst extract = (regex, defaultValue = 'Tidak ada', checkNotFound = false) => {\nconst result = (text.match(regex) || [null, defaultValue])[1].trim();\nreturn checkNotFound && result === 'Not found.' ? 'Tidak ada' : result;\n};\nresolve({\nstatus: 200,\nresult: {\nemail: email,\nphotoProfile: extract(/Custom profile picture !\\s*=>\\s*(.*)/, 'Tidak ada'),\nlastEditProfile: extract(/Last profile edit : (.*)/),\ngoogleID: extract(/Gaia ID : (.*)/),\nuserTypes: extract(/User types : (.*)/),\ngoogleChat: {\nentityType: extract(/Entity Type : (.*)/),\ncustomerID: extract(/Customer ID : (.*)/, 'Tidak ada', true)\n},\ngooglePlus: {\nenterpriseUser: extract(/Entreprise User : (.*)/)\n},\nmapsData: {\nprofilePage: extract(/Profile page : (.*)/)\n},\nipAddress: text.includes('Your IP has been blocked by Google') ? 'Di blokir oleh Google' : 'Aman',\ncalendar: text.includes('No public Google Calendar') ? 'Tidak ada' : 'Ada'\n}\n});\n} catch (error) {\nresolve({\nstatus: 404,\nmsg: 'Email tidak ditemukan atau terjadi kesalahan!'\n});\n}\n});\n};\nexports.run = {\nusage: ['gmailstalk'],\nhidden: [],\nuse: 'email@gmail.com',\ncategory: 'searching',\nasync: async (m, { func, mecha }) => {\nif (!m.args[0]) return m.reply(func.example(m.cmd, 'example@gmail.com'))\nif (!m.args[0].endsWith('@gmail.com')) return m.reply('Masukkan email Gmail yang valid!')\nawait checkGmail(m.args[0]).then(data => {\nif (data.status == 404) return m.reply(data.msg)\nlet txt = `‰πÇ  *GMAIL CHECKER*\\n`\ntxt += `\\n‚ó¶  *Email:* ${data.result.email}`\ntxt += `\\n‚ó¶  *Photo Profile:* ${data.result.photoProfile}`\ntxt += `\\n‚ó¶  *Last Edit:* ${data.result.lastEditProfile}`\ntxt += `\\n‚ó¶  *Google ID:* ${data.result.googleID}`\ntxt += `\\n‚ó¶  *User Types:* ${data.result.userTypes}`\ntxt += `\\n‚ó¶  *Entity Type:* ${data.result.googleChat.entityType}`\ntxt += `\\n‚ó¶  *Customer ID:* ${data.result.googleChat.customerID}`\ntxt += `\\n‚ó¶  *Enterprise User:* ${data.result.googlePlus.enterpriseUser}`\ntxt += `\\n‚ó¶  *Profile Page:* ${data.result.mapsData.profilePage}`\ntxt += `\\n‚ó¶  *IP Status:* ${data.result.ipAddress}`\ntxt += `\\n‚ó¶  *Calendar:* ${data.result.calendar}`\nmecha.reply(m.chat, txt, m)\n})\n},\nlimit: true\n}"
    },
    {
      "path": "main.js",
      "code": "\"process.on('uncaughtException', console.error);\\nprocess.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';\\nrequire('events').EventEmitter.defaultMaxListeners = 500;\\nconst { Baileys, InvCloud } = require('./system/baileys.js');\\nconst { Jadibot } = new (require('./system/jadibot.js'));\\nconst { groupAdd, groupRemove } = new (require('./system/groups'));\\nconst func = require('./system/functions');\\nconst chalk = require('chalk');\\nconst fs = require('fs');\\nconst path = require('path');\\nconst cron = require('node-cron');\\nconst { platform } = require('os');\\n\\n/* additional config */\\nrequire('./config')\\n\\n/* temporary database */\\nglobal.jadibot = {};\\n\\nconst socket = new Baileys({\\npairing: {\\n...global.pairing\\n},\\n...global.config\\n});\\n\\n/* starting to connect */\\nsocket.on('connect', async res => {\\n/* write connection log */\\nif (res && typeof res === 'object' && res.message) func.logFile(res.message, 'connect')\\n})\\n\\n/* print error */\\nsocket.on('error', async error => {\\n/* write error log */\\nconsole.log(chalk.redBright.bold(error.message))\\nif (error && typeof error === 'object' && error.message) func.logFile(error.message, 'error')\\n})\\n\\n/* bot is connected */\\nsocket.on('ready', async (mecha) => {\\n/* auto restart if ram usage is over */\\nconst ramCheck = setInterval(async () => {\\nvar ramUsage = process.memoryUsage().rss\\nif (ramUsage >= (global.max_ram * 1000000000)) {\\nclearInterval(ramCheck)\\nawait global.database.save(global.db);\\nconsole.info(`RAM telah mencapai ${global.max_ram} GB, Sistem merestart bot secara otomatis.`)\\nprocess.send('reset');\\n}\\n}, 60 * 1000)\\n\\n/* create temp directory if doesn't exists */\\nif (!fs.existsSync('./sampah')) fs.mkdirSync('./sampah')\\n\\n/* create jadibot session directory if doesn't exists */\\nif (!fs.existsSync('./jadibot')) fs.mkdirSync('./jadibot')\\n\\n/* additional events */\\nrequire('./system/events.js')(mecha)\\n\\n/* clear temp folder every 10 minutes */\\nsetInterval(async () => {\\ntry {\\nconst tmpFiles = fs.readdirSync('./sampah')\\nif (tmpFiles.length > 10) {\\ntmpFiles.filter(v => !v.endsWith('.file')).map(v => fs.unlinkSync('./sampah/' + v))\\n}\\n\\n/* this source from @jarspay */\\nconst TIME = 1000 * 60 * 60\\nconst filename = []\\nconst files = await fs.readdirSync('./session')\\nfor (const file of files) {\\nif (file != 'creds.json') filename.push(path.join('./session', file))\\n}\\n\\nawait Promise.allSettled(filename.map(async (file) => {\\nconst stat = await fs.statSync(file)\\nif (stat.isFile() && (Date.now() - stat.mtimeMs >= TIME)) {\\nif (platform() === 'win32') {\\nlet fileHandle\\ntry {\\nfileHandle = await fs.openSync(file, 'r+')\\n} catch (e) {} finally {\\nawait fileHandle.close()\\n}\\n}\\nawait fs.unlinkSync(file)\\n}\\n}))\\n} catch {}\\n}, 60 * 1000 * 10)\\n\\n/* save databasel every 30 seconds */\\nsetInterval(async () => {\\nif (global.db) await global.database.save(global.db);\\n}, 30_000)\\n\\nfor (let x of global.db.jadibot) {\\nif (x.status && global.db.users[x.number] && global.db.users[x.number].jadibot && fs.existsSync(`${x.session}/creds.json`) && typeof global.jadibot[x.number] == 'undefined') await Jadibot({\\nmecha: mecha,\\nnumber: x.number,\\nstate: true\\n})\\n}\\n\\n})\\n\\n/* print all message object */\\nsocket.on('message', async extra => {\\nconst { m, store } = extra;\\nInvCloud(store);\\nrequire('./handler')(socket.mecha, extra);\\nif (global.db.setting[m.bot].autoread && m.chat === 'status@broadcast') {\\nif (m.message?.protocolMessage) return;\\nawait socket.mecha.readMessages([m.key])\\nif (m.broadcast) {\\nif (!fs.existsSync('./database/story.json')) fs.writeFileSync('./database/story.json', JSON.stringify([], null, 2))\\nlet story = JSON.parse(fs.readFileSync('./database/story.json'));\\nstory.push({\\nmtype: m.mtype,\\npushname: m.pushname,\\nsender: m.sender,\\ncaption: m.budy,\\nmsg: {\\nkey: m.key,\\nmessage: m.message\\n}\\n})\\nfs.writeFileSync('./database/story.json', JSON.stringify(story, null, 2))\\n}\\n};\\n})\\n\\n/* print deleted message object */\\nsocket.on('message.delete', extra => {\\nif (!extra || !extra.delete || !extra.origin || extra.origin.fromMe || extra.origin.isBot || !extra.origin.sender) return\\nif (!extra.delete) return\\nif (extra.origin.isGc && global.db.groups[extra.origin.chat] && global.db.groups[extra.origin.chat].antidelete) return socket.mecha.copyNForward(extra.origin.chat, extra.delete, false, {\\nquoted: extra.delete,\\nephemeralExpiration: extra.origin.expiration || 86400\\n})\\n})\\n\\n/* AFK detector */\\n//socket.on('presence.update', extra => console.log(extra))\\n\\n/* Anti Call Auto Reject */\\nsocket.on('caller', extra => {\\nrequire('./system/anticall')(socket.mecha, extra)\\n})\\n\\nsocket.on('group.add', async extra => groupAdd(socket.mecha, extra))\\nsocket.on('group.remove', extra => groupRemove(socket.mecha, extra))\\n//socket.on('group.promote', extra => console.log(extra))\\n//socket.on('group.demote', extra => console.log(extra))\""
    },
    {
      "path": "index.js",
      "code": "\"update-vip main.js\""
    }
  ],
  "remove": [
    "plugins/a.js",
    "plugins/b.js",
    "plugins/c.js",
    "plugins/d.js",
    "plugins/e.js",
    "plugins/f.js",
    "plugins/y.js",
    "plugins/menu.js"
  ]
}